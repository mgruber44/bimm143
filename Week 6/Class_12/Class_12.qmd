---
title: "Class 12: Transcriptomics and the analysis of RNA-Seq data"
author: "Max Gruber"
date: 05/12/2023
format: pdf
---

# 1. Bioconductor and DESeq2 setup

```{r}
#install.packages("BiocManager")
#BiocManager::install()
#BiocManager::install("DESeq2")

library(BiocManager)
library(DESeq2)
```

# 2. Import countData and colData

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")

```

```{r}
head(counts)
nrow(counts)
```

```{r}
head(metadata)

table(metadata$dex)['control']
```

### Q**1.** How many genes are in this dataset?

There are 38,694 genes (`r nrow(counts)`) in this dataset.

### Q**2.** How many 'control' cell lines do we have?

We have 4 'control' cell lines (using code `table(metadata$dex)`).

# 3. Toy differential gene expression

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

```{r}
metadata[,'dex']

metadata[,'dex'] == 'control'

metadata[metadata[,'dex'] == 'control',]
```

```{r}
control <- metadata[metadata[,"dex"]=="control",]

control$id

head(counts[,control$id])

control.counts <- counts[ ,control$id]
```

```{r}
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

### Q**3.** How would you make the above code in either approach more robust?

```{r}
control.counts <- counts[,control$id]
control.means <- rowMeans(control.counts)
```

Dividing by 4 makes the code non-reproducible if used in another context (e.g. more replicates/samples). As such, using rowMeans rather than dividing by an actual number makes the code more robust/usable outside of this dataset.

### **Q4.** Follow the same procedure for the `treated` samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called `treated.mean`)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
treated.counts <- counts[ ,treated$id]
treated.mean <- rowSums( treated.counts )/4 
head(treated.mean)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
colSums(meancounts)
```

### Q**5 (a).** Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated")
```

### **Q5 (b).**You could also use the **ggplot2** package to make this figure producing the plot below. What **geom\_?()** function would you use for this plot?

```{r}
library(ggplot2)

#meancounts

ggplot(data = meancounts) +
       aes(x = control.mean, y= treated.mean) +
       geom_point()
```

### **Q6.** Try plotting both axes on a log scale. What is the argument to **plot()** that allows you to do this?

```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated", log = 'xy')
```

The argument is `log`.

\
To calculate the log2 of the fold change between treated and control...\

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

### **Q7.** What is the purpose of the `arr.ind` argument in the **which()** function call above? Why would we then take the first column of the output and need to call the **unique()**function?

The `arr.ind` argument returns the row and column positions where there are TRUE values, which will tell us which genes and samples have a count of zero (want to ignore any genes that have zero counts in order to avoid linearizing the matrix). `Unique()` will make sure that none of the rows are counted twice if there are zero entries in both samples.

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

### Q**8.** Using the `up.ind` vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

```{r}
sum(up.ind)
```

There are 250 up regulated genes greater than 2 fc level.

### Q**9.** Using the `down.ind` vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(down.ind)
```

There are 367 downregulated genes greater than 2 fc level.

### Q**10.** Do you trust these results? Why or why not?

Not entirely, mainly because we are missing the statistics. The actual numbers/code makes sense, but we don't know if the differences are significant or generated by chance. We don't know if the number of replicates we have used is enough to say whether or not the differences we see are real, and as such more analysis is needed to confirm the results.

# 4. DESeq2 analysis

```{r}
library(DESeq2)
citation("DESeq2")
```

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

## DESeq analysis

```{r}
#results(dds)
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
res
```

```{r}
summary(res)

res05 <- results(dds, alpha=0.05)
summary(res05)
```

# 5. Adding annotation data

```{r}
library("AnnotationDbi")

#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
```

```{r}
head(res)
```

### **Q11.** Run the **mapIds()** function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called `res$entrez`, `res$uniprot` and`res$genename`.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

```{r}
write.csv(res[ord,], "deseq_results.csv")
```

# 6. Data Visualization

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

```{r}
#BiocManager::install("EnhancedVolcano")

library(EnhancedVolcano)
```

```{r}
x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```
